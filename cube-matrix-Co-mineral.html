<!DOCTYPE html>
<html lang="en">
	<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Interactive 3D Cube Matrix</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			#buttons {
				position: absolute;
				left: 0px;
				top: 0px;
			}

			#myCanvas {
				position: absolute;
				left: 10px;
				top: 120px;
			}
			
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	
	<body>
		<div id="buttons">
		<input type="file" name="filename" id="filename">
		<input type="button" value="Color by logarithmic values: log(v*2)" onClick="colorByLogarithmicValues();" />
		<br><b id="cellInfo" style="background-color: lightgrey;"></b>
		</div>
		<canvas id="myCanvas" width="50" height="500" >
		<script src="three.min.js"></script>
		<script src="TrackballControls.js"></script>
		<script src="rainbowvis.js"></script>   
		<script src="jquery-1.9.1.js"></script>
		<script>	
			var container;
			var camera, controls, scene, renderer;
			var raycaster = new THREE.Raycaster();
			var csvRows;
			var radius = 100, cubeValue = [];
			//2D vector
			var mouse = new THREE.Vector2(), intersectedObject, objectOriginalHex, objectOriginalOpacity ;
			var cubeOffset = new THREE.Vector3( 10, 10, 10 );			
			
			//Use JQuery to load a CSV file, code adapted from http://jsfiddle.net/dx1dbx6w/
			$("#filename").change(function(e) {
				var ext = $("input#filename").val().split(".").pop().toLowerCase();

				if($.inArray(ext, ["csv"]) == -1) {
					alert('Upload CSV');
					return false;
				}
    
				if (e.target.files != undefined) {
					var reader = new FileReader();
					reader.onload = function(e) {
					//Get the records from the csv file
					csvRows=e.target.result.split("\n");				
//create the 3d cube
				init();
				animate();				
//
				};
				reader.readAsText(e.target.files.item(0));
				}
				return false;
			});
			


			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				//Camera with perspective projection.
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 40;
				
				//Controls for the operations to rotate, zoom in and zoom out  
				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 4.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				
				//Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.
				scene = new THREE.Scene();

				//This light's color gets applied to all the objects in the scene globally.
				scene.add( new THREE.AmbientLight( 0x555555 ) );

				//Affects objects using MeshLambertMaterial or MeshPhongMaterial.
				var light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 0, 0, 1 ).normalize();
				scene.add( light );
				
				//Insert a 3d cube matrix 				
				//old_createCubeMatrix(72, 72, 1, 1.2);
				
				
				// Add axes
				var axes2d = buildAxes( 1000 );
				scene.add( axes2d );
				
				//We suppose the input csv is a recangtangle matrix (i.e. all rows have same lenght)
				createCubeMatrix(csvRows[0].split(",").length, csvRows.length, 1.2);
				
				//The WebGL renderer displays scenes using WebGL, if your device supports it.
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;
				container.appendChild(renderer.domElement);

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
//				renderer.domElement.addEventListener( 'mousemove', onMouseMove );
				window.addEventListener( 'resize', onWindowResize, false );
			}

			//Create a 3d cube matrix				
function createCubeMatrix(m, n, offset) {
				offset = offset !== undefined ? offset : 2.0;
				
				//BoxGeometry is the quadrilateral primitive geometry class.
				var geom = new THREE.BoxGeometry(1, 1, 1);
				var color = new THREE.Color();

				var matrix = new THREE.Matrix4();
				var quaternion = new THREE.Quaternion();

				//Here for screen coordinates, (x=0, y=0) means the center of the screen
				//The following value is for the top left corner of the cube matrix layer to be plotted
				var xMin = -offset * ((m-3) / 2.0); 
				var yMin = offset * ((n-3) / 2.0);

				var csvColumnsInOneRow;
				
				var numberOfItems = 874; //Because the values in the matrix are from 0 to 874
				var rainbow = new Rainbow(); //From rainbowvis.js ;  See  https://github.com/anomal/RainbowVis-JS
				rainbow.setNumberRange(0, numberOfItems);
				//The spectrum has a great impact on the outlook of the resulting cube matrix
				//May extend a function on the user interface  - this will be useful for users to find areas of interst
				rainbow.setSpectrum('blue', 'cyan', 'turquoise', 'lime', 'green', 'yellowgreen', 'yellow', 'orange', 'orangered', 'red');
				//rainbow.setSpectrum('blue', 'green', 'yellow', 'orange', 'red');
				
				createColorLegend(numberOfItems);
				
				var hexColor;
				var mat, box;
				var boxID = 0;
				
				var csvColumnsInFirstRow = csvRows[0].split(",");
				var csvColumnsInSecondRow = csvRows[1].split(","); 				
				for (i = 0, y = yMin; i < n-2; i++, y -= offset) { //1) Begin with the top row, y the same for cubes in the row
					csvColumnsInOneRow=csvRows[i+2].split(",");

					for (j = 0, x = xMin; j < m-2; j++, x += offset) { //2) Then plot cubes towards right on the x axis, x increases
						
						hexColor = '#' + rainbow.colourAt(csvColumnsInOneRow[j+2]);
						
						//A material for non-shiny (Lambertian) surfaces, evaluated per vertex.	//{color: (csvColumnsInOneRow[j]*0xffffff)/100}			
						mat = new THREE.MeshLambertMaterial({color: hexColor}); //Assign color to each cube according to the vaule of cells in the csv file
						//Mesh object. Mesh( geometry, material ). Geometry defines the object's structure. Material defines the object's appearance.
						box = new THREE.Mesh(geom, mat);
						box.position.x = x;
						box.position.y = y;
						scene.add(box);
						
							box.name = boxID;
							cubeValue[boxID] = [] ; //create a 2-D array 
							cubeValue[boxID][0] = csvColumnsInOneRow[j+2] ; //value in the cell
							cubeValue[boxID][1] = csvColumnsInFirstRow[j+2] ; //First occurance Age on x axis
							cubeValue[boxID][2] = csvColumnsInSecondRow[j+2] ; //Mineral on x axis
							cubeValue[boxID][3] = csvColumnsInOneRow[0] ; ////First occurance Age on y axis
							cubeValue[boxID][4] = csvColumnsInOneRow[1] ; //Mineral on y axis
							
							boxID++;	
					}
				}
			}			

function createColorLegend( maxValue ) {

var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");

ctx.clearRect(0, 0, 50, 500); //clear the whole canvas (including the area of the text)

var my_gradient = ctx.createLinearGradient(0, 480, 0, 0);
my_gradient.addColorStop(0, "blue");
my_gradient.addColorStop(1/9, "cyan");
my_gradient.addColorStop(2/9, "turquoise");
my_gradient.addColorStop(3/9, "lime");
my_gradient.addColorStop(4/9, "green");
my_gradient.addColorStop(5/9, "yellowgreen");
my_gradient.addColorStop(6/9, "yellow");
my_gradient.addColorStop(7/9, "orange");
my_gradient.addColorStop(8/9, "orangered");
my_gradient.addColorStop(1, "red");

ctx.fillStyle = my_gradient;
ctx.fillRect(0, 10, 10, 480);
ctx.strokeText("0", 10, 490);
ctx.strokeText(Math.round(maxValue/9).toString(), 10, 490-(480/9));
ctx.strokeText(Math.round(maxValue*2/9).toString(), 10, 490-(480*2/9));
ctx.strokeText(Math.round(maxValue*3/9).toString(), 10, 490-(480*3/9));
ctx.strokeText(Math.round(maxValue*4/9).toString(), 10, 490-(480*4/9));
ctx.strokeText(Math.round(maxValue*5/9).toString(), 10, 490-(480*5/9));
ctx.strokeText(Math.round(maxValue*6/9).toString(), 10, 490-(480*6/9));
ctx.strokeText(Math.round(maxValue*7/9).toString(), 10, 490-(480*7/9));
ctx.strokeText(Math.round(maxValue*8/9).toString(), 10, 490-(480*8/9));
ctx.strokeText(maxValue.toString(), 10, 10);

}			
			
function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;  //1.12 works perfect. It is weird that I cannot use '1' here - there will be an offset in the result - Now I know - it is caused by the div on the top of the window - make the div's position to be absolute solved the issue
				// find intersections

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( scene.children );
				var cellInformation ;


				if ( intersects.length > 0 ) {  //there are more than one objects intersected with the mouse

					if ( intersectedObject != intersects[ 0 ].object ) { // the mouse had a big move and now points at a different object(s)

						if ( intersectedObject ) //intersectedObject (i.e. the previous object being pointed at) already exists and is not null
						{   //restore the color and opacity of the previous object
							intersectedObject.material.emissive.setHex( objectOriginalHex );
							intersectedObject.material.opacity = objectOriginalOpacity;
						}
						
						// choose the object closet to mouse as the result
						intersectedObject = intersects[ 0 ].object;
						
						// capture color and opacity of the object for later use --> to restore when mouse move away
						objectOriginalHex = intersectedObject.material.emissive.getHex();
						objectOriginalOpacity = intersectedObject.material.opacity;
						
						// highlight the object by changing its color and opacity
						intersectedObject.material.emissive.setHex( 0xff0000 );
						intersectedObject.material.opacity = 1.0;
						
						//show attributes of the object in the window
						cellInformation = '<font color="red">' + 'X-mineral: ' + cubeValue[intersectedObject.name][2] + "</font>, "  //mineral on x axis	
							+ 'First occurance time: ' + cubeValue[intersectedObject.name][1] + " Ma; <br>"  //first occurance time
							+ '<font color="green">' + 'Y-mineral: ' + cubeValue[intersectedObject.name][4] + "</font>, "   //element on y axis
							+ 'First occurance time: ' + cubeValue[intersectedObject.name][3] + " Ma; <br>" //first occurance time
							+ 'Number of localities where both minerals occur: ' + cubeValue[intersectedObject.name][0] ; //value in the cell
							
						document.getElementById('cellInfo').innerHTML = cellInformation ;
						
					} //if (intersectedObject == intersects[ 0 ].object)  -->that means the mouse had a tiny move and still points at the same object, so no change 

				} else { //the mouse moves away and points at no objects

						if ( intersectedObject ) //intersectedObject (i.e. the previous object being poinited at) already exists and is not null
						{   //restore the color and opacity of the previous object
							intersectedObject.material.emissive.setHex( objectOriginalHex );
							intersectedObject.material.opacity = objectOriginalOpacity;
						}

					intersectedObject = null;  //clean up the intersectedObject variable
					
					document.getElementById('cellInfo').setAttribute('value', ' ') ;
				}

			}
			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

function colorByLogarithmicValues(){
				var maxLogValue = Math.round( Math.log(874*2) ); //the highese value is 875; multiply by 2 is because there are a few original values '1'. Make it to '2' can avoid log value of '0' and make the cube visiable in result.  
				var rainbow = new Rainbow(); //From rainbowvis.js ;  See  https://github.com/anomal/RainbowVis-JS
				rainbow.setNumberRange(0, maxLogValue);
				rainbow.setSpectrum('blue', 'cyan', 'turquoise', 'lime', 'green', 'yellowgreen', 'yellow', 'orange', 'orangered', 'red');
				
				var roundedLogValue = 0;
				var colorCode = 0;

scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {
		roundedLogValue = Math.round( Math.log(cubeValue[object.name][0]*2) ); //multiply by 2 is because there are a few original values '1'. Make it to '2' can avoid log value of '0' and make the cube visiable in result. This is only used for the color and does not change the original attribute value of the cube.
		if (roundedLogValue < 0) { roundedLogValue=0; }
		colorCode = '0x' + rainbow.colourAt( roundedLogValue ) ; //cannot   use '#' for '0x'
		object.material.color.setHex( colorCode ); // cannot use   object.material.color = colorCode 
	
    }
});

animate();

createColorLegend(maxLogValue);

}			
	function buildAxes( length ) {
		var axes = new THREE.Object3D();

		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
		//axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
		//axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z

		return axes;

	}

	function buildAxis( src, dst, colorHex, dashed ) {
		var geom = new THREE.Geometry(),
			mat; 

		if(dashed) {
			mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 1, gapSize: 1 });
		} else {
			mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
		}

		geom.vertices.push( src.clone() );
		geom.vertices.push( dst.clone() );
		geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

		var axis = new THREE.Line( geom, mat, THREE.LinePieces );

		return axis;

	}
			
/*
			function onMouseMove( e ) {
				mouse.x = e.clientX;
				mouse.y = e.clientY;
			}
*/			
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			
			function render() {
				controls.update();
				renderer.render( scene, camera );
			}
			
		</script>
	
</body></html>