<!DOCTYPE html>
<html lang="en">
	<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Interactive 3D Cube Matrix</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
			
			#buttons {
				position: absolute;
				left: 0px;
				top: 0px;
			}
			
			#elementButtons {
				position: absolute;
				left: 0px;
				bottom: 0px;
			}
		</style>
	</head>
	
	<body>
	<div id="buttons">
		<input type="file" name="filename" id="filename"/>
	<input type="button" value="Cube opacity +" onClick="increaseOpacity();" />
	<input type="button" value="Cube opacity -" onClick="decreaseOpacity();" />
	<input type="button" value="Opacity by mineral counts" onClick="opacityByMineralCounts();" />
	<input type="button" value="Color by logarithmic values" onClick="colorByLogarithmicValues();" />
	<input type="button" value="X offset +" onClick="increaseXoffset();" />
	<input type="button" value="X offset -" onClick="decreaseXoffset();" />
	<input type="button" value="Y offset +" onClick="increaseYoffset();" />
	<input type="button" value="Y offset -" onClick="decreaseYoffset();" />
	<input type="button" value="Z offset +" onClick="increaseZoffset();" />
	<input type="button" value="Z offset -" onClick="decreaseZoffset();" /> 
	<input type="button" value="Rebuild cube matrix" onClick="rebuildAllCubes();" />
	<br><b id="cellInfo" style="background-color: lightgrey;"></b>
	</div>
	<div id="elementButtons"> 
	</div>
		<script src="three.min.js"></script>
		<script src="TrackballControls.js"></script>
		<script src="rainbowvis.js"></script>   
		<script src="jquery-1.9.1.js"></script>
		<script>	
			var container;
			var camera, controls, scene, renderer;
			var raycaster = new THREE.Raycaster();
			var csvRows;
			var deafaultOffset = 1.2;
			var radius = 100, cubeValue = [];
			

			
			//2D vector
			var mouse = new THREE.Vector2(), intersectedObject, objectOriginalHex, objectOriginalOpacity ;
			var cubeOffset = new THREE.Vector3( 10, 10, 10 );			
			
			//Use JQuery to load a CSV file, code adapted from http://jsfiddle.net/dx1dbx6w/
			$("#filename").change(function(e) {
				var ext = $("input#filename").val().split(".").pop().toLowerCase();

				if($.inArray(ext, ["csv"]) == -1) {
					alert('Upload CSV');
					return false;
				}
    
				if (e.target.files != undefined) {
					var reader = new FileReader();
					reader.onload = function(e) {
					//Get the records from the csv file
					csvRows=e.target.result.split("\n");				

				if (scene != undefined) { // clear all entities in the scene if they exist
					removeAllEntities();
				}
				
//create the 3d cube				
				init();
				animate();				
//
				};
				reader.readAsText(e.target.files.item(0));
				}
				return false;
			});
			


			function init() {
				container = document.createElement( 'div' );
				container.setAttribute("id", "cubeDiv");
				document.body.appendChild( container );
				
				//Camera with perspective projection.
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 80;
				//camera.position.set( 50, 50, 50 );
				//camera.lookAt( new THREE.Vector3() );
				
				
				
				//Controls for the operations to rotate, zoom in and zoom out  
				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 2.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.9;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				
				//Scenes allow you to set up what and where is to be rendered by three.js. This is where you place objects, lights and cameras.
				scene = new THREE.Scene();

				//This light's color gets applied to all the objects in the scene globally.
				scene.add( new THREE.AmbientLight( 0x555555 ) );

				//Affects objects using MeshLambertMaterial or MeshPhongMaterial.
				var light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );
				
				//Insert a 3d cube matrix 				
				//old_createCubeMatrix(72, 72, 1, 1.2);
				
				// Add axes
				axes = buildAxes( 1000 );
				scene.add( axes );
				
				//We suppose the input csv is a recangtangle matrix (i.e. all rows have same lenght)
				createCubeMatrix(30, 30, 30, deafaultOffset);
				
				//The WebGL renderer displays scenes using WebGL, if your device supports it.
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;
				container.appendChild(renderer.domElement);

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
//				renderer.domElement.addEventListener( 'mousemove', onMouseMove );
				window.addEventListener( 'resize', onWindowResize, false );
			}

			//Create a 3d cube matrix				
			function createCubeMatrix(m, n, p, offset) {
				offset = offset !== undefined ? offset : 2.0;
				
				//BoxGeometry is the quadrilateral primitive geometry class.
				var geom = new THREE.BoxGeometry(1, 1, 1);
				var color = new THREE.Color();

				var matrix = new THREE.Matrix4();
				var quaternion = new THREE.Quaternion();

				//Here for screen coordinates, (x=0, y=0) means the center of the screen
				//The following value is for the top left corner of the cube matrix layer to be plotted
				var xMin = -offset * ((m-1) / 2.0); 
				var yMin = offset * ((n-1) / 2.0);
				var zMin = -offset * ((p-1) / 2.0);

				var csvColumnsInFirstRow;  
				var csvColumnsInOneRow;
				
				var numberOfItems = 4150; //Because element O has 4138 minerals 
				var rainbow = new Rainbow(); //From rainbowvis.js ;  See  https://github.com/anomal/RainbowVis-JS
				rainbow.setNumberRange(0, numberOfItems);
				//The spectrum has a great impact on the outlook of the resulting cube matrix
				//May extend a function on the user interface  - this will be useful for users to find areas of interst
				rainbow.setSpectrum('blue', 'cyan', 'turquoise', 'lime', 'green', 'yellowgreen', 'yellow', 'orange', 'orangered', 'red');
				//rainbow.setSpectrum('blue', 'green', 'yellow', 'orange', 'red');
				
				var hexColor;
				var mat, box;
				
				var boxID = 0;
				
				csvColumnsInFirstRow = csvRows[0].split(",");
				//the following codes apply to the specific data structure in the csv file
				for (k = 1, z = zMin; k < p*30+1; k += 30, z += offset) { //avoid the first row
					for (i = 0, y = yMin; i < m; i++, y -= offset) { //1) Begin with the top row, y the same for cubes in the row
						csvColumnsInOneRow=csvRows[i+k].split(",");

						for (j = 0, x = xMin; j < n; j++, x += offset) { //2) Then plot cubes towards right on the x axis, x increases
							
							hexColor = '#' + rainbow.colourAt(csvColumnsInOneRow[j+2]); //avoid the first two columns
							
							//A material for non-shiny (Lambertian) surfaces, evaluated per vertex.	//{color: (csvColumnsInOneRow[j]*0xffffff)/100}			
							mat = new THREE.MeshLambertMaterial({color: hexColor,  transparent: true, opacity: 0.5}); //Assign color to each cube according to the vaule of cells in the csv file, and set trasparent and opacity
							//var mat = new THREE.MeshNormalMaterial({color: hexColor,  transparent: true, opacity: csvColumnsInOneRow[j+2]/4150});
							//Mesh object. Mesh( geometry, material ). Geometry defines the object's structure. Material defines the object's appearance.
							box = new THREE.Mesh(geom, mat);
							box.position.x = x;
							box.position.y = y;
							box.position.z = z;
							box.is_ob = true;
							scene.add(box);
							
							box.name = boxID;
							cubeValue[boxID] = [] ; //create a 2-D array 
							cubeValue[boxID][0] = csvColumnsInOneRow[j+2] ; //value in the cell
							cubeValue[boxID][1] = csvColumnsInFirstRow[j+2] ; //element on x axis
							cubeValue[boxID][2] = csvColumnsInOneRow[1] ; //element on y axis
							cubeValue[boxID][3] = csvColumnsInOneRow[0] ; //element on z axis
							if ((boxID > 0) && (cubeValue[boxID][3] != cubeValue[boxID-1][3])) {
								document.getElementById('elementButtons').innerHTML +=
								  '<input type="button" value=' + cubeValue[boxID][3] + ' ' +
								  'onClick="visualizePlane('+ "\'" + cubeValue[boxID][3] + "\'" + ');" />' ;
							}
							boxID++;	
						}
					}
				}
			}	
			
function createPlaneMatrix(m, n, p, offset, element1) {
				offset = offset !== undefined ? offset : 2.0;
				
				//BoxGeometry is the quadrilateral primitive geometry class.
				var geom = new THREE.BoxGeometry(1, 1, 1);
				var color = new THREE.Color();

				var matrix = new THREE.Matrix4();
				var quaternion = new THREE.Quaternion();

				//Here for screen coordinates, (x=0, y=0) means the center of the screen
				//The following value is for the top left corner of the cube matrix layer to be plotted
				var xMin = -offset * ((m-1) / 2.0); 
				var yMin = offset * ((n-1) / 2.0);
				var zMax = offset * ((p-1) / 2.0);

				var csvColumnsInFirstRow;  
				var csvColumnsInOneRow;
				
				var numberOfItems = 4150; //Because element O has 4138 minerals 
				var rainbow = new Rainbow(); //From rainbowvis.js ;  See  https://github.com/anomal/RainbowVis-JS
				rainbow.setNumberRange(0, numberOfItems);
				//The spectrum has a great impact on the outlook of the resulting cube matrix
				//May extend a function on the user interface  - this will be useful for users to find areas of interst
				rainbow.setSpectrum('blue', 'cyan', 'turquoise', 'lime', 'green', 'yellowgreen', 'yellow', 'orange', 'orangered', 'red');
				//rainbow.setSpectrum('blue', 'green', 'yellow', 'orange', 'red');
				
				var hexColor;
				var mat, box;
				
				var boxID = 0;
				
				csvColumnsInFirstRow = csvRows[0].split(",");
				//the following codes apply to the specific data structure in the csv file
				for (k = 1; k < p*30+1; k += 1) { //avoid the first row
				     csvColumnsInOneRow=csvRows[k].split(",");
				if (csvColumnsInOneRow[0] == element1)
				{
					for (i = 0, y = yMin; i < m; i++, y -= offset) { //1) Begin with the top row, y the same for cubes in the row
						csvColumnsInOneRow=csvRows[i+k].split(",");

						for (j = 0, x = xMin; j < n; j++, x += offset) { //2) Then plot cubes towards right on the x axis, x increases
							
							hexColor = '#' + rainbow.colourAt(csvColumnsInOneRow[j+2]); //avoid the first two columns
							
							//A material for non-shiny (Lambertian) surfaces, evaluated per vertex.	//{color: (csvColumnsInOneRow[j]*0xffffff)/100}			
							mat = new THREE.MeshLambertMaterial({color: hexColor,  transparent: true, opacity: 0.5}); //Assign color to each cube according to the vaule of cells in the csv file, and set trasparent and opacity
							//var mat = new THREE.MeshNormalMaterial({color: hexColor,  transparent: true, opacity: csvColumnsInOneRow[j+2]/4150});
							//Mesh object. Mesh( geometry, material ). Geometry defines the object's structure. Material defines the object's appearance.
							box = new THREE.Mesh(geom, mat);
							box.position.x = x + 40;
							box.position.y = y;
							box.position.z = zMax;
							box.is_ob = true;
							scene.add(box);
							
							box.name = boxID;
							/*
							cubeValue[boxID] = [] ; //create a 2-D array 
							cubeValue[boxID][0] = csvColumnsInOneRow[j+2] ; //value in the cell
							cubeValue[boxID][1] = csvColumnsInFirstRow[j+2] ; //element on x axis
							cubeValue[boxID][2] = csvColumnsInOneRow[1] ; //element on y axis
							cubeValue[boxID][3] = csvColumnsInOneRow[0] ; //element on z axis
							if ((boxID > 0) && (cubeValue[boxID][3] != cubeValue[boxID-1][3])) {
								document.getElementById('elementButtons').innerHTML +=
								  '<input type="button" value=' + cubeValue[boxID][3] + ' ' +
								  'onClick="visualizePlane('+ "\'" + cubeValue[boxID][3] + "\'" + ');" />' ;
							}
							*/
							boxID++;	
						}
					}}
				}
			}			
					
/*			
			//Create a 3d cube matrix				
			function old_createCubeMatrix(m, n, p, offset) {
				offset = offset !== undefined ? offset : 2.0;
				
				//BoxGeometry is the quadrilateral primitive geometry class.
				var geom = new THREE.BoxGeometry(1, 1, 1);
				var color = new THREE.Color();

				var matrix = new THREE.Matrix4();
				var quaternion = new THREE.Quaternion();


				var xMin = -offset * ((m-1) / 2.0);
				var yMin = -offset * ((n-1) / 2.0);
				var zMin = -offset * ((p-1) / 2.0);
				
				for (i = 0, x = xMin; i < m; i++, x += offset) {
					for (j = 0, y = yMin; j < n; j++, y += offset) {
						for (k = 0, z = zMin; k < p; k++, z += offset) {
							//A material for non-shiny (Lambertian) surfaces, evaluated per vertex.				
							var mat = new THREE.MeshLambertMaterial({color: Math.random()*0xffffff});
							//Mesh object. Mesh( geometry, material ). Geometry defines the object's structure. Material defines the object's appearance.
							var box = new THREE.Mesh(geom, mat);
							box.position.x = x;
							box.position.y = y;
							box.position.z = z;
							scene.add(box);
						}	
					}
				}
			}			
*/		

var planeContainer ;
var camera1, controls1, scene1, renderer1;

function visualizePlane (element) {

if (document.getElementById('planeDiv') != null)	
{
	var planeElem = document.getElementById('planeDiv');
    planeElem.parentNode.removeChild(planeElem);
}

planeContainer = document.createElement( 'div' );                        
planeContainer.setAttribute("id", "planeDiv");
document.getElementById('cubeDiv').appendChild( planeContainer );

var testElement= element;
createPlaneMatrix(30, 30, 30, deafaultOffset, testElement);
			
animate();	

}

	function buildAxes( length ) {
		var axes = new THREE.Object3D();

		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
		axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z

		return axes;

	}

	function buildAxis( src, dst, colorHex, dashed ) {
		var geom = new THREE.Geometry(),
			mat; 

		if(dashed) {
			mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
		} else {
			mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
		}

		geom.vertices.push( src.clone() );
		geom.vertices.push( dst.clone() );
		geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

		var axis = new THREE.Line( geom, mat, THREE.LinePieces );

		return axis;

	}

function removeAllEntities(){
    var obj, i;
            for ( i = scene.children.length - 1; i >= 0 ; i -- ) {
                obj = scene.children[ i ];
                scene.remove(obj);
            }
animate();
			
}	

function rebuildAllCubes(){
removeAllCubes();
createCubeMatrix(30, 30, 30, deafaultOffset);
animate();
}
	
function removeAllCubes(){
    var obj, i;
            for ( i = scene.children.length - 1; i >= 0 ; i -- ) {
                obj = scene.children[ i ];
                if ( obj.is_ob) {
                    scene.remove(obj);
                }
            }		
}	
	
	
function increaseOpacity(){ // update the oppacity of all cubes
//var cubeOpacityValue = document.getElementById('opacityValue').value;
scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {		
		object.material.opacity += 0.1 ;
    }
});

animate();

}

function decreaseOpacity(){ // update the oppacity of all cubes
//var cubeOpacityValue = document.getElementById('opacityValue').value;
scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {	
		object.material.opacity -= 0.1 ;
    }
});

animate();

}

function opacityByMineralCounts(){
scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {
		object.material.opacity = cubeValue[object.name][0]/4150 ;
    }
});

animate();

}

function colorByLogarithmicValues(){
				var maxLogValue = Math.round( Math.log(4150) ); //Because element O has 4138 minerals; 
				var rainbow = new Rainbow(); //From rainbowvis.js ;  See  https://github.com/anomal/RainbowVis-JS
				rainbow.setNumberRange(0, maxLogValue);
				rainbow.setSpectrum('blue', 'cyan', 'turquoise', 'lime', 'green', 'yellowgreen', 'yellow', 'orange', 'orangered', 'red');
				
				var roundedLogValue = 0;
				var colorCode = 0;

scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {
		roundedLogValue = Math.round( Math.log(cubeValue[object.name][0]) );
		if (roundedLogValue < 0) { roundedLogValue=0; }
		colorCode = '0x' + rainbow.colourAt( roundedLogValue ) ; //cannot   use '#' for '0x'
		object.material.color.setHex( colorCode ); // cannot use   object.material.color = colorCode 
	
    }
});

animate();

}
	
function increaseXoffset(){
scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {
		object.translateX(object.position.x*0.5); //offset is x*0.5, so new x' = (1+0.5)*x
    }
});

animate();

}

function decreaseXoffset(){
scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {
		object.translateX(-object.position.x/3); //new x' = x/1.5, so offset = -(x'-(x'/1.5)) = -x/3
    }
});

animate();

}

function increaseYoffset(){
scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {
		object.translateY(object.position.y*0.5); 
    }
});

animate();

}

function decreaseYoffset(){
scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {
		object.translateY(-object.position.y/3); 
    }
});

animate();

}

function increaseZoffset(){
scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {
		object.translateZ(object.position.z*0.5);  
    }
});

animate();

}

function decreaseZoffset(){
scene.traverse (function (object)
{
    if (object instanceof THREE.Mesh)
    {
		object.translateZ(-object.position.z/3);  
    }
});

animate();

}
	
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;  //1.12 works perfect. It is weird that I cannot use '1' here - there will be an offset in the result - Now I know - it is caused by the div on the top of the window - make the div's position to be absolute solved the issue
				// find intersections

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( scene.children );
				var cellInformation ;


				if ( intersects.length > 0 ) {  //there are more than one objects intersected with the mouse

					if ( intersectedObject != intersects[ 0 ].object ) { // the mouse had a big move and now points at a different object(s)

						if ( intersectedObject ) //intersectedObject (i.e. the previous object being pointed at) already exists and is not null
						{   //restore the color and opacity of the previous object
							intersectedObject.material.emissive.setHex( objectOriginalHex );
							intersectedObject.material.opacity = objectOriginalOpacity;
						}
						
						// choose the object closet to mouse as the result
						intersectedObject = intersects[ 0 ].object;
						
						// capture color and opacity of the object for later use --> to restore when mouse move away
						objectOriginalHex = intersectedObject.material.emissive.getHex();
						objectOriginalOpacity = intersectedObject.material.opacity;
						
						// highlight the object by changing its color and opacity
						intersectedObject.material.emissive.setHex( 0xff0000 );
						intersectedObject.material.opacity = 1.0;
						
						//show attributes of the object in the window
						cellInformation = '<font color="red">' + 'X: ' + cubeValue[intersectedObject.name][1] + '</font>' + ", "  //element on x axis	
							+ '<font color="green">' + 'Y: ' + cubeValue[intersectedObject.name][2] + '</font>' + ", "   //element on y axis
							+ '<font color="blue">' + 'Z: ' + cubeValue[intersectedObject.name][3] + '</font>' + ", "  //element on z axis
							+ 'Mineral count value: ' + cubeValue[intersectedObject.name][0] ; //value in the cell
							
						document.getElementById('cellInfo').innerHTML = cellInformation ;
						
					} //if (intersectedObject == intersects[ 0 ].object)  -->that means the mouse had a tiny move and still points at the same object, so no change 

				} else { //the mouse moves away and points at no objects

						if ( intersectedObject ) //intersectedObject (i.e. the previous object being poinited at) already exists and is not null
						{   //restore the color and opacity of the previous object
							intersectedObject.material.emissive.setHex( objectOriginalHex );
							intersectedObject.material.opacity = objectOriginalOpacity;
						}

					intersectedObject = null;  //clean up the intersectedObject variable
					
					document.getElementById('cellInfo').setAttribute('value', ' ') ;
				}

			}
/*
			function onMouseMove( e ) {
				mouse.x = e.clientX;
				mouse.y = e.clientY;
			}
*/			
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			
			function render() {
				controls.update();
				renderer.render( scene, camera );
			}
			
		</script>
	
</body></html>